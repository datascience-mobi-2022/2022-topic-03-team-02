---
title: "Analysis Part 5"
author: "Mich√®le, Michel, Lennart, Sebastian"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
library("tidyverse")
```

## predict shift with correlation

load data:
```{r}
df_normalized <- readRDS("RDeeP_HeLa_Mitosis_normalized.rds")
df_normalized_combined <- readRDS("RDeeP_HeLa_Mitosis_normalized_combined.rds")
```

RDeePs should have a lower correlation between RNase und Ctrl conditions than non-RDeePs:
```{r}
tdf <- as.data.frame(t(df_normalized_combined))
cor(tdf$EED_HUMAN[1:25], tdf$EED_HUMAN[26:50])  # RDeeP
cor(tdf$`1433B_HUMAN`[1:25], tdf$`1433B_HUMAN`[26:50]) # non-RDeeP
```

Using this, we can try to make a linear regression model.
```{r}
# create df that will contain important information for linear modelling
df_lm <- data.frame(row.names = colnames(tdf))

# add vector containing correlation between rnase and control condition to df
vec_cor <- apply(tdf, 2, function(x) {
  cor(x[1:25], x[26:50])
})
df_lm$correlation <- vec_cor
df_lm$shift <- shift_global
```

To train and test our model with our data, we split it so that 80% of the will train the model and 20% will test it. The split is random
```{r}
set.seed(123)
n <- nrow(df_lm)
x <- sample(c(TRUE, FALSE), n, replace=TRUE, prob=c(0.8, 0.2))
df_lm_train <- df_lm[x, ]
df_lm_test <- df_lm[!x, ]
```

Now, we can train the model using df_lm_train.
```{r}
linear_model <- lm(shift ~ correlation, data = df_lm_train)
summary(linear_model)
```

We can now check some things to decide whether this model is valid or not (residuals normally distributed, residuals not correlated to explanatory variable).
```{r}
# normal distribution of residuals? 
hist(linear_model$residuals, breaks = 20)

qqnorm(linear_model$residuals)
qqline(linear_model$residuals)

## correlation residuals x-values? 
cor(df_lm_train$correlation, linear_model$residuals)
plot(df_lm_train$correlation, linear_model$residuals, pch = 20)
```
The residuals seem to be quite normally distributed with mean = 0. They also seem to be not correlated at all with the explanatory variable (correlation between Ctrl and RNase conditions).

After we have trained our model and verified its accuracy, we can test it by using df_lm_test.
```{r}
pm <- predict.lm(linear_model, newdata = df_lm_test, se.fit = TRUE, interval = "confidence")

df_lm_predict <- as.data.frame(cbind(df_lm_test$shift, pm$fit))
```

```{r}
plot(
  df_lm_predict$V1,
  df_lm_predict$fit,
  pch = 20,
  col = 'blue',
  xlab = 'Real values',
  ylab = 'Predicted values'
); abline(0, 1, col = "blue", lwd = 5)
```
!!! Model describes left shift good, but right shifts not !!!

We can also try to evaluate how accurate our model is by having a look at the confidence intervals.
```{r}
counter <- 0

for (i in 1:nrow(df_lm_predict)) {
  if (df_lm_predict$V1[i] > df_lm_predict$lwr[i] & df_lm_predict$V1[i] < df_lm_predict$upr[i]) {
    counter <- counter + 1
  }
}

counter / nrow(df_lm_predict) * 100  
```

Only 6% of the real shifts are in between the boarders of the confidence interval...
We can also have a look at the standard errors for every prediction.
```{r}
mean(pm$se.fit)
```


## same model but absolut shift values

```{r}
# df for model training
df_lm_train_ab <- df_lm_train
df_lm_train_ab$shift <- abs(df_lm_train_ab$shift)

# df for model testing
df_lm_test_ab <- df_lm_test
df_lm_test_ab$shift <- abs(df_lm_test_ab$shift)
```

```{r}
linear_model_ab <- lm(shift ~ correlation, data = df_lm_train_ab)
summary(linear_model_ab)
```

```{r}
# normal distribution of residuals? 
hist(linear_model_ab$residuals, breaks = 20)

qqnorm(linear_model_ab$residuals)
qqline(linear_model_ab$residuals)

## correlation residuals x-values? 
cor(df_lm_train_ab$correlation, linear_model_ab$residuals)
plot(df_lm_train_ab$correlation, linear_model_ab$residuals, pch = 20)
```

```{r}
pm_ab <- predict.lm(linear_model_ab, newdata = df_lm_test_ab, se.fit = TRUE, interval = "confidence")

df_lm_predict_ab <- as.data.frame(cbind(df_lm_test_ab$shift, pm_ab$fit))
```

```{r}
plot(
  df_lm_predict_ab$V1,
  df_lm_predict_ab$fit,
  pch = 20,
  col = 'blue',
  xlab = 'Real values',
  ylab = 'Predicted values'
); abline(0, 1, col = "blue", lwd = 5)
```

```{r}
counter <- 0

for (i in 1:nrow(df_lm_predict_ab)) {
  if (df_lm_predict_ab$V1[i] > df_lm_predict_ab$lwr[i] & df_lm_predict_ab$V1[i] < df_lm_predict_ab$upr[i]) {
    counter <- counter + 1
  }
}

counter / nrow(df_lm_predict_ab) * 100  
```

```{r}
mean(pm_ab$se.fit)
```




## more regression models

regression model: using differences between ctrl and rnase conditions

```{r}
# create df that will contain important information for linear modelling
df_lm <- data.frame(row.names = colnames(tdf))

# add vector containing correlation between rnase and control condition to df
vec_cor <- apply(tdf, 2, function(x) {
  cor(x[1:25], x[26:50])
})
df_lm$correlation <- vec_cor
df_lm$shift <- shift_global

# add row with absolute shifts
df_lm$ab_shift <- abs(df_lm$shift)

# add differences between rnase and ctrl conditions
for (i in 1:nrow(df_normalized_combined)) {
  
  s <- 0
  
  for (j in 1:25) {
    s <- s + abs(df_normalized_combined[i, j] - df_normalized_combined[i, j + 25])
  }
  
  df_lm$dif[i] <- s
  
}

df_lm$rdeep <- df_umap$rdeep
for (i in 1:nrow(df_lm)) {
  if (df_lm$rdeep[i] == "rdeep") {
    df_lm$rdeep2[i] <- 1
  } else {
    df_lm$rdeep2[i] <- 0
  }
}
```

```{r}
# split dataset into train and test 
set.seed(123)
n <- nrow(df_lm)
x <- sample(c(TRUE, FALSE), n, replace=TRUE, prob=c(0.8, 0.2))
df_lm_train <- df_lm[x, ]
df_lm_test <- df_lm[!x, ]
```

```{r}
# train linear model
linear_model <- lm(ab_shift ~ correlation + dif, data = df_lm_train)
summary(linear_model)
```

```{r}
# normal distribution of residuals? 
hist(linear_model$residuals, breaks = 20)

qqnorm(linear_model$residuals)
qqline(linear_model$residuals)

## correlation residuals x-values? 
cor(df_lm_train$dif, linear_model$residuals)
plot(df_lm_train$dif, linear_model$residuals, pch = 20)
```

```{r}
pm <- predict.lm(linear_model, newdata = df_lm_test, se.fit = TRUE, interval = "confidence")

df_lm_predict <- as.data.frame(cbind(df_lm_test$ab_shift, pm$fit))
```

```{r}
plot(
  df_lm_predict$V1,
  df_lm_predict$fit,
  pch = 20,
  col = 'blue',
  xlab = 'Real values',
  ylab = 'Predicted values'
); abline(0, 1, col = "blue", lwd = 5)
```



## comparison with data bases

Finally, we want to compare our results with given results (e.g. databases)
```{r}
df_rdeep <- readRDS("RDeeP_HeLa_Mitosis_rdeep.rds")

rdeep <- rownames(df_rdeep)
non_rdeep <- rownames(df_normalized)[-df_rdeep$index]
```

Before executing the next step, load HS_non_RBPs.RData and HS_RBPs.RData!

```{r}
# number of our RDeePs which are RBPs
counter <- 0

for (i in rdeep) {
  if (i %in% HS_RBPs$Entry_Name.x) {
    counter <- counter + 1
  }
}
counter
```

```{r}
# number of our RDeePs which are non RBPs

counter <- 0

for (i in rdeep) {
  if (i %in% HS_non_RBPs$Entry_Name.x) {
    counter <- counter + 1
  }
}
counter
```

```{r}
# number of our non RDeePs which are RBPs

counter <- 0

for (i in non_rdeep) {
  if (i %in% HS_RBPs$Entry_Name.x) {
    counter <- counter + 1
  }
}
counter
```

```{r}
# number of our non RDeePs which are non RBPs

counter <- 0

for (i in non_rdeep) {
  if (i %in% HS_non_RBPs$Entry_Name.x) {
    counter <- counter + 1
  }
}
counter
```


## comparison with local maxima

To have a look at the local maxima as well, we are going to calculate a global profile for every protein's local maxima by computing the squared sums of the maxima's fractions for both conditions. Later, we can use this information to compare the results with our RDeePs in order to see whether leaving out the local maxima was making our results less accurate.

```{r}
df_local_maxima <- readRDS("RDeeP_HeLa_Mitosis_local_maxima.rds")
```

```{r}
# compute squared sums of fractions for both conditions

df_local_maxima_qs <-
  data.frame(row.names = rownames(df_local_maxima))

for (i in 1:nrow(df_local_maxima_qs)) {
  df_local_maxima_qs$ctrl[i] <-
    sqrt(
      df_local_maxima$ctrl_local_maximum1_fraction[i] ** 2 + df_local_maxima$ctrl_local_maximum2_fraction[i] ** 2 +   df_local_maxima$ctrl_local_maximum3_fraction[i] ** 2 + df_local_maxima$ctrl_local_maximum4_fraction[i] ** 2 +     df_local_maxima$ctrl_local_maximum5_fraction[i] ** 2
    )
  
  df_local_maxima_qs$rnase[i] <-
    sqrt(
      df_local_maxima$rnase_local_maximum1_fraction[i] ** 2 + df_local_maxima$rnase_local_maximum2_fraction[i] ** 2 +   df_local_maxima$rnase_local_maximum3_fraction[i] ** 2 + df_local_maxima$rnase_local_maximum4_fraction[i] ** 2 +   df_local_maxima$rnase_local_maximum5_fraction[i] ** 2
    )
}
```

```{r}
# add difference to data frame (absolute difference)

df_local_maxima_qs$dif <- abs(df_local_maxima_qs$ctrl - df_local_maxima_qs$rnase)
shift_proteins_l <- c(rownames(df_local_maxima_qs)[which(df_local_maxima_qs$dif > 5)])
length(shift_proteins_l)
```

```{r}
# RDeePs if global and local

shift_proteins_lg <- c(intersect(shift_proteins, shift_proteins_l))
length(c(intersect(shift_proteins_lg, sig_dif_proteins_rep)))
```

```{r}
# RDeePs if global or local

x1 <- c(intersect(shift_proteins, sig_dif_proteins_rep))
x2 <- c(intersect(shift_proteins_l, sig_dif_proteins_rep))

x3 <- c(x1, x2)
length(unique(x3))
```







