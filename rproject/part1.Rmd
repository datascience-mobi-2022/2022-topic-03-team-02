---
title: "Analysis Part 1"
author: "Michel, Lennart, Mich√®le, Sebastian"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(cache = TRUE)
library("tidyverse")
```

## load data

The data frame is loaded as describe on the Github page for project 3.
```{r}
MS_Table <- read.table("RDeeP_HeLa_Mitosis.csv", header = TRUE, row.names = 1, sep = ";")
```

```{r}
head(rownames(MS_Table),12)
```

```{r}
head(colnames(MS_Table),12)
```

## data cleanup

First, we want to check whether every column's data type is numeric.
```{r}
sum(apply(MS_Table, 2, is.numeric)) == ncol(MS_Table)
glimpse(MS_Table)
```

Every column's data type is numeric (double)! 

We want to remove every row that has only zeros or negative numbers in at least one of the 3 replicates for each condition (RNase or Ctrl). Those rows will not help us to identify shifts and therefore to identify RNA-depending proteins.
```{r}
# find all proteins that contain only zeros in at least one replicate

del_row <- c()
# save those proteins (row number) in del_row

for (i in c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNase_Rep1", "RNase_Rep2", "RNase_Rep3")) {
  # iterate through all replicates
  
  for (j in 1:nrow(MS_Table)) {
    # iterate through all values
    
    if (sum(MS_Table[j, grep(i, colnames(MS_Table))]) <= 0) {
      del_row <- append(del_row, j)
    }
  }
}
del_row_sort <- sort(unique(del_row))
del_row_sort
```

Then we want to check whether the rows contain only zeros in all replicates, or just in one or two replicates, which could allow us to use mean values as a replacement.

```{r}
#Keep the rows in which only one replicate has no values, but the other replicates have normal values
#del_row_sort gives the numbers of the rows which include only zeros in at least one replicate
#del_row_refined = sort(unique(del_row)[table(del_row)<=2])

#for (i in del_row__refined) {
  #iterate through all rows in which there are only zeros in at least one replicate
  
#  for(j in c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNase_Rep1", "RNase_Rep2", "RNase_Rep3")){
    #iterate through all replicates
    
#       if (sum(MS_Table[i, grep(j, colnames(MS_Table))]) <= 0) {
#        row_means_possible<- append(row_means_possible, i)
#        }
#    }
#  }
```


Therefore, we remove rows 691, 3045, 3575, 4057, 5568, 6732 and 7112.
```{r}
# remove the rows saved in del_row_sort
MS_Table <- MS_Table[-del_row_sort,]
```

All in all, we removed 7 rows that contained only zeros in at least one of the replicates of the two conditions (RNase or Control).

## describing the structure of our data

Dimension of our data frame:
```{r}
dim(MS_Table)
```

Some row names:
```{r}
head(rownames(MS_Table))
```

Some column names:
```{r}
head(colnames(MS_Table))
```

## normalize protein amount per fraction

In the first normalization step, we want to set every protein's amount within one replicate to be 100 per conditions. For example, the protein represented by row 1 has a sum over all 25 fractions of 100 in Ctrl_Rep1. To archive this, we begin with building 6 smaller data frames for every replicate of each condition.
```{r}
# create df that contains all rows of control replicate 1
x <- grep("Ctrl_Rep1", colnames(MS_Table))
Ctrl_Rep1 <- MS_Table[, x]

# create df that contains all rows of RNase replicate 1
y <- grep("RNase_Rep1", colnames(MS_Table))
RNase_Rep1 <- MS_Table[, y]

# create df that contains all rows of control replicate 2
z <- grep("Ctrl_Rep2", colnames(MS_Table))
Ctrl_Rep2 <- MS_Table[, z]

# create df that contains all rows of RNase replicate 2
a <- grep("RNase_Rep2", colnames(MS_Table))
RNase_Rep2 <- MS_Table[, a]

# create df that contains all rows of control replicate 3
b <- grep("Ctrl_Rep3", colnames(MS_Table))
Ctrl_Rep3 <- MS_Table[, b]

# create df that contains all rows of RNase replicate 3
c <- grep("RNase_Rep3", colnames(MS_Table))
RNase_Rep3 <- MS_Table[, c]
```

Following, we can set each row of every replicate's data frame to have a sum of 100.
```{r}
# normalization step 1 of control replicate 1
for (i in 1:nrow(Ctrl_Rep1)) {
  x <- sum(Ctrl_Rep1[i, ]) / 100
  Ctrl_Rep1[i, ] = Ctrl_Rep1[i, ] / x
}

# normalization step 1 of RNase replicate 1
for (i in 1:nrow(RNase_Rep1)) {
  x <- sum(RNase_Rep1[i, ]) / 100
  RNase_Rep1[i, ] = RNase_Rep1[i, ] / x
}

# normalization step 1 of control replicate 2
for (i in 1:nrow(Ctrl_Rep2)) {
  x <- sum(Ctrl_Rep2[i, ]) / 100
  Ctrl_Rep2[i, ] = Ctrl_Rep2[i, ] / x
}

# normalization step 1 of RNase replicate 2
for (i in 1:nrow(RNase_Rep2)) {
    x <- sum(RNase_Rep2[i, ]) / 100
    RNase_Rep2[i, ] = RNase_Rep2[i, ] / x
}

# normalization step 1 of control replicate 3
for (i in 1:nrow(Ctrl_Rep3)) {
  x <- sum(Ctrl_Rep3[i, ]) / 100
  Ctrl_Rep3[i, ] = Ctrl_Rep3[i, ] / x
}

# normalization step 1 of RNase replicate 3
for (i in 1:nrow(RNase_Rep3)) {
  x <- sum(RNase_Rep3[i, ]) / 100
  RNase_Rep3[i, ] = RNase_Rep3[i, ] / x
}
```

Now, we can verify if the sum of every row really equals 100. If everything went correctly, we should get 6 times TRUE!
```{r}
# test if the sum of each row divided by 100 is the number of rows will tell us whether the sum is 100
sum(Ctrl_Rep1) / 100 == nrow(Ctrl_Rep1)
sum(RNase_Rep1) / 100 == nrow(RNase_Rep1)
sum(Ctrl_Rep2) / 100 == nrow(Ctrl_Rep2)
sum(RNase_Rep2) / 100 == nrow(RNase_Rep2)
sum(Ctrl_Rep3) / 100 == nrow(Ctrl_Rep3)
sum(RNase_Rep3) / 100 == nrow(RNase_Rep3)
```

Seems like everything went fine! Now, we can combine the replicate's data frames again to make one single data frame containing all normalized data.

```{r}
df_normalized <- as.data.frame(cbind(Ctrl_Rep1, Ctrl_Rep2, Ctrl_Rep3, RNase_Rep1, RNase_Rep2, RNase_Rep3))
dim(df_normalized) == dim(MS_Table)
sum(df_normalized[1,]) / 6 == 100
df_normalized_copy <- df_normalized
```

## evaluating reproducibility of our data

We want to evaluate the reproducibility of our data by computing the correlation between the replicates of the two conditions for every protein. By doing it that way, we can not only evaluate similarities between the replicates of one condition, we can also sort out single proteins which data do not seem to be reproducible. (First, we create a vector for every protein containing all its values of one replicate, for every replicate and condition.) 

```{r}
tdf_normalized <- as.data.frame(t(df_normalized))

# correlation between ctrl1 and ctrl2 for every protein
c1c2 <- c()
for (i in 1:ncol(tdf_normalized)) {
  c1c2 <- append(c1c2, (cor(tdf_normalized[1:25, i], tdf_normalized[26:50, i])))
}

# correlation between ctrl1 and ctrl3 for every protein
c1c3 <- c()
for (i in 1:ncol(tdf_normalized)) {
  c1c3 <- append(c1c3, (cor(tdf_normalized[1:25, i], tdf_normalized[51:75, i])))
}
 
# correlation between ctrl2 and ctrl3 for every protein 
c2c3 <- c()
for (i in 1:ncol(tdf_normalized)) {
  c2c3 <- append(c2c3, (cor(tdf_normalized[26:50, i], tdf_normalized[51:75, i])))
}

# correlation between rnase1 and rnase2 for every protein
r1r2 <- c()
for (i in 1:ncol(tdf_normalized)) {
  r1r2 <- append(r1r2, (cor(tdf_normalized[76:100, i], tdf_normalized[101:125, i])))
}

# correlation between rnase1 an rnase3 for every protein
r1r3 <- c()
for (i in 1:ncol(tdf_normalized)) {
  r1r3 <- append(r1r3, (cor(tdf_normalized[76:100, i], tdf_normalized[126:150, i])))
}
  
# correlation between rnase2 and rnase3 for every protein
r2r3 <- c()
for (i in 1:ncol(tdf_normalized)) {
  r2r3 <- append(r2r3, (cor(tdf_normalized[101:125, i], tdf_normalized[126:150, i])))
}
```

In order to test which threshold fits the best we try different ones, and plot how many proteins would be removed. We are testing threshold values from 0 to 0.8. Everything above would mean throwing away too many proteins, with high correlation. 

```{r}
tres_values <- c()

for (t in seq(0, 0.8, by = 0.05)) {
  tc <- c()
  
  for (i in 1:ncol(tdf_normalized)) {
    if (c1c2[i] < t) {
      tc <- append(tc, colnames(tdf_normalized)[i])
    }
  }
  for (i in 1:ncol(tdf_normalized)) {
    if (c1c3[i] < t) {
      tc <- append(tc, colnames(tdf_normalized)[i])
    }
  }
  for (i in 1:ncol(tdf_normalized)) {
    if (c2c3[i] < t) {
      tc <- append(tc, colnames(tdf_normalized)[i])
    }
  }
  for (i in 1:ncol(tdf_normalized)) {
    if (r1r2[i] < t) {
      tc <- append(tc, colnames(tdf_normalized)[i])
    }
  }
  for (i in 1:ncol(tdf_normalized)) {
    if (r1r3[i] < t) {
      tc <- append(tc, colnames(tdf_normalized)[i])
    }
  }
  for (i in 1:ncol(tdf_normalized)) {
    if (r2r3[i] < t) {
      tc <- append(tc, colnames(tdf_normalized)[i])
    }
  }
  tres_values <- append(tres_values, length(unique(tc)))
}
```

To evaluate a fitting threshold value we are going to plot the number of proteins which would be removed against the respective threshold value. 

```{r}
plot(seq(0, 0.8, 0.05), tres_values, type = "b", xlab = "threshold value", ylab = "number of removed proteins", main = "")
```
Value 0.6 seems to be a good fit. We can also have a look at the correlation values we just computed by visualizing them with a plot. For example, we can have a look at the distribution:

```{r}
cor_vec <- c(c1c2, c1c3, c2c3, r1r2, r1r3, r2r3)
hist(cor_vec)
```
Here it also looks like 0.6 is a good threshold value. 

To visualize the analysis we just performed, we can plot two replicates which are not strongly correlated and two replicates which are strongly correlated.
```{r}
par(mfrow = c(1, 2))

# no strong correlation
colnames(tdf_normalized)[which(r1r3 == min(r1r3))]
df_plot1 <-
  data.frame(x = tdf_normalized$K2C1_HUMAN[76:100], y = tdf_normalized$K2C1_HUMAN[126:150])
plot1 <- ggplot(df_plot1, aes(x, y)) +
  geom_point() +
  geom_smooth() +
  labs(x = "K2C1_HUMAN RNase Rep1", y = "K2C1_HUMAN RNase Rep3")

# strong correlation
set.seed(124)
x <- which(c1c2 < 0.97)
colnames(tdf_normalized)[sample(which(c1c2[x] > 0.90), 1)]

df_plot2 <-
  data.frame(x = tdf_normalized$ECE1_HUMAN[1:25] , y = tdf_normalized$ECE1_HUMAN[26:50])
plot2 <- ggplot(df_plot2, aes(x, y)) +
  geom_point() +
  geom_smooth() +
  labs(x = "ECE1_HUMAN Ctrl Rep1", y = "ECE1_HUMAN Ctrl Rep2")

# plot
cowplot::plot_grid(plot1, plot2, labels = "AUTO")
```

Now, we must remove the proteins with correlation values below 0.6.

```{r}
t = 0.6
tc <- c()

for (i in 1:ncol(tdf_normalized)) {
  if (c1c2[i] < t) {
    tc <- append(tc, colnames(tdf_normalized)[i])
  } 
}
for (i in 1:ncol(tdf_normalized)) {
  if (c1c3[i] < t) {
    tc <- append(tc, colnames(tdf_normalized)[i])
  } 
}
for (i in 1:ncol(tdf_normalized)) {
  if (c2c3[i] < t) {
    tc <- append(tc, colnames(tdf_normalized)[i])
  } 
}
for (i in 1:ncol(tdf_normalized)) {
  if (r1r2[i] < t) {
    tc <- append(tc, colnames(tdf_normalized)[i])
  } 
}
for (i in 1:ncol(tdf_normalized)) {
  if (r1r3[i] < t) {
    tc <- append(tc, colnames(tdf_normalized)[i])
  } 
}
for (i in 1:ncol(tdf_normalized)) {
  if (r2r3[i] < t) {
    tc <- append(tc, colnames(tdf_normalized)[i])
  } 
}

length(unique(tc))
utc <- unique(tc)
remove_proteins <- c()

for (i in 1:length(utc)) {
  remove_proteins <- append(remove_proteins, which(rownames(df_normalized) == utc[i]))
}
if (length(remove_proteins) != 0) {
  df_normalized <- df_normalized[-remove_proteins,]
}
dim(df_normalized)
```

Now, we have removed 64 proteins due to an expected low reproducibility. We can save this data frame as a new file **RDeeP_HeLa_Mitosis_normalized.rds**:

```{r}
saveRDS(df_normalized, file = "DeeP_HeLa_Mitosis_normalized.rds")
```

```{r}
df_normalized <- readRDS("DeeP_HeLa_Mitosis_normalized.rds")
sum(df_normalized) / 600 == nrow(df_normalized)
```

## combining replicates using mean value

In this step, we want to combine the three replicates of every condition by using the mean value of the three replicates' values. To do so, we first split the `df_normalized` data frame into one data frame containing only the control replicates and one data frame containing only the RNase replicates.

```{r}
df_Ctrl <- df_normalized[, grep("Ctrl", colnames(df_normalized))]
df_RNase <- df_normalized[, grep("RNase", colnames(df_normalized))]
```

Now, we can process the two data frames so that they contain only the mean values of the triplicates.

```{r}
# control condition
df_Ctrl_c <- data.frame()
for (i in 1:nrow(df_Ctrl)) {
  for (j in 1:25) {
    x <- mean(c(df_Ctrl[i, j], df_Ctrl[i, j + 25], df_Ctrl[i, j + 50]))
    df_Ctrl_c[i, j] = x
  }
}

# RNase condition
df_RNase_c <- data.frame()
for (i in 1:nrow(df_RNase)) {
  for (j in 1:25) {
    x <- mean(c(df_RNase[i, j], df_RNase[i, j + 25], df_RNase[i, j + 50]))
    df_RNase_c[i, j] = x
  }
}
```

```{r}
# test if mean values in df_Ctrl_c are computed correctly
score1 <- 0
for (i in 1:nrow(df_Ctrl)) {
  for (j in 1:25) {
    if (mean(c(df_Ctrl[i, j], df_Ctrl[i, j + 25], df_Ctrl[i, j + 50])) != df_Ctrl_c[i, j]) {
      score1 <- score1 + 1
    }
  }
}
score1 == 0

# test if mean values in df_RNase_c are computed correctly
score2 <- 0
for (i in 1:nrow(df_RNase)) {
  for (j in 1:25) {
    if (mean(c(df_RNase[i, j], df_RNase[i, j + 25], df_RNase[i, j + 50])) != df_RNase_c[i, j]) {
      score2 <- score2 + 1
    }
  }
}
score2 == 0
```

Now both, the Ctrl and the RNase data frames, consist of the mean values of the replicates and are scaled to 100 units of each protein. We can now join the both data frames to one again, containing all proteins but only 50 instead of 150 columns.

```{r}
df_normalized_combined <- cbind(df_Ctrl_c, df_RNase_c)
rownames(df_normalized_combined) <- rownames(df_normalized)

cnc <- sapply(1:25, function(x) {paste("Fraction", x, "_Ctrl", sep = "")})
cnr <- sapply(1:25, function(x) {paste("Fraction", x, "_RNase", sep = "")})
colnames(df_normalized_combined)[1:25] <- cnc
colnames(df_normalized_combined)[26:50] <- cnr
```

Lastly, we can save that data frame as a file again to avoid running the code above again and again.

```{r}
# for report
saveRDS(tres_values, file = "tres_values.rds")

saveRDS(df_normalized_combined, file = "DeeP_HeLa_Mitosis_normalized_combined.rds")
```








